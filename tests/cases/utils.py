import uuid
from sqlmodel import Session
from app.models.cases import Case, CaseRequest


def is_list_of_dicts(items):
    """Check if variable is a list of dicts."""
    return isinstance(items, list) and all(isinstance(item, dict) for item in items)


def assert_dicts_equal(dict1, dict2):
    """
    Recursively assert that two dictionaries are equal, ignoring key order.
    """
    dict1 = remove_auto_generated_fields(dict1)
    dict2 = remove_auto_generated_fields(dict2)

    dict1_keys = sorted(dict1.keys())
    dict2_keys = sorted(dict2.keys())
    assert dict1_keys == dict2_keys, f"Keys mismatch: {dict1_keys} != {dict2_keys}"

    for key in dict1:
        if isinstance(dict1[key], dict) and isinstance(dict2[key], dict) and dict1[key]:
            assert_dicts_equal(dict1[key], dict2[key])  # Recursively check nested dicts
        elif is_list_of_dicts(dict1[key]) and is_list_of_dicts(dict2[key]):
            assert len(dict1[key]) == len(
                dict2[key]
            ), f"{key} does not contain the same count of items in both dicts"
            for index, item in enumerate(dict1[key]):
                assert_dicts_equal(dict1[key][index], dict2[key][index])
        else:
            assert (
                dict1[key] == dict2[key]
            ), f"Mismatch at key '{key}': {dict1[key]} != {dict2[key]}"


def create_test_case(session: Session) -> Case:
    data = get_case_test_data()
    return CaseRequest(**data).create(session)


def get_case_test_data() -> dict:
    return {
        "case_type": "Check if your client qualifies for legal aid",
        "notes": [
            {"note_type": "Other", "content": ""},
            {"note_type": "Adaptation", "content": "This is user needs adaptations"},
        ],
        "people": [
            {
                "name": "string",
                "address": "string",
                "phone_number": "0202 21212",
                "postcode": "SW1 1AA",
                "email": "user@example.com",
            }
        ],
        "case_tracker": {"gtm_anon_id": "string", "journey": {}},
        "eligibility_outcomes": [
            {"eligibility_type": "CCQ", "outcome": "In scope", "answers": {}}
        ],
        "case_adaptations": {
            "languages": ["EN", "CY"],
            "needed_adaptations": ["BSL - Webcam", "Text Relay"],
        },
    }


def remove_auto_generated_fields(data: dict) -> dict:
    """Remove autogenerated fields from a given dict"""
    ret_data = data.copy()
    auto_generated_fields = ["id", "created_at", "updated_at"]
    for key, value in data.items():
        if key in auto_generated_fields:
            ret_data.pop(key)
        elif isinstance(value, uuid.UUID):
            ret_data.pop(key)

    return ret_data
